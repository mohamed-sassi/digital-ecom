{"version":3,"sources":["webpack:///./node_modules/three/examples/jsm/loaders/obj2/OBJLoader2Parser.js","webpack:///./node_modules/three/examples/jsm/loaders/obj2/shared/MeshReceiver.js","webpack:///./node_modules/three/examples/jsm/loaders/obj2/shared/MaterialHandler.js","webpack:///./node_modules/three/examples/jsm/loaders/OBJLoader2.js"],"names":["OBJLoader2Parser","this","logging","enabled","debug","scope","callbacks","onProgress","text","_onProgress","onAssetAvailable","payload","_onAssetAvailable","onError","errorMessage","_onError","onLoad","object3d","message","_onLoad","contentRef","legacyMode","materials","materialPerSmoothingGroup","useOAsMesh","useIndices","disregardNormals","vertices","colors","normals","uvs","rawMesh","objectName","groupName","activeMtlName","mtllibName","faceType","subGroups","subGroupInUse","smoothingGroup","splitMaterials","normalized","real","counts","doubleIndicesCount","faceCount","mtlCount","smoothingGroupCount","inputObjectCount","outputObjectCount","globalCounts","faces","lineByte","currentByte","totalBytes","prototype","constructor","_resetRawMesh","_pushSmoothingGroup","setMaterialPerSmoothingGroup","setUseOAsMesh","setUseIndices","setDisregardNormals","setMaterials","Object","assign","setCallbackOnAssetAvailable","undefined","Function","setCallbackOnProgress","setCallbackOnError","setCallbackOnLoad","console","log","error","setLogging","_configure","matKeys","keys","matNames","length","join","printedConfig","name","info","execute","arrayBuffer","time","arrayBufferView","Uint8Array","byteLength","buffer","Array","bufferPointer","slashesCount","word","code","_processLine","String","fromCharCode","_finalizeParsing","timeEnd","executeLegacy","char","bufferLength","i","lineDesignation","reconstructString","content","start","stop","line","trim","push","parseFloat","_checkFaceType","_buildFace","_processCompletedMesh","mtlName","_checkSubGroup","smoothingGroupInt","parseInt","isNaN","smoothCheck","index","materialName","indexMappingsCount","indexMappings","indices","faceIndexV","faceIndexU","faceIndexN","updateSubGroupInUse","faceIndexVi","indexPointerV","indexPointerC","faceIndexUi","indexPointerU","faceIndexNi","indexPointerN","mappingName","indicesPointer","_createRawMeshReport","_finalizeRawMesh","meshOutputGroup","meshOutputGroupTemp","absoluteVertexCount","absoluteIndexMappingsCount","absoluteIndexCount","absoluteColorCount","absoluteNormalCount","absoluteUvCount","result","haveMesh","_buildMesh","progressBytesPercent","toFixed","meshOutputGroups","vertexFA","Float32Array","selectedMaterialIndex","materialGroup","materialOrg","material","materialNameOrg","indexUA","Uint32Array","colorFA","normalFA","uvFA","haveVertexColors","materialNames","createMultiMaterial","materialIndex","materialIndexMapping","materialGroups","vertexFAOffset","indexUAOffset","colorFAOffset","normalFAOffset","uvFAOffset","materialGroupOffset","materialGroupLength","oodIndex","hasOwnProperty","materialCloneInstructions","materialProperties","vertexColors","flatShading","cmd","type","matCheck","count","set","materialIndexLine","createdReport","progress","numericalValue","params","meshName","multiMaterial","buffers","geometryType","parserFinalReport","MeshReceiver","materialHandler","onMeshAlter","_setCallbacks","buildMeshes","meshPayload","key","bufferGeometry","setAttribute","setIndex","computeVertexNormals","skinIndex","Uint16Array","skinWeight","multiMaterials","getMaterial","addGroup","mesh","callbackOnMeshAlterResult","meshes","useOrgMesh","detail","isDisregardMesh","providesAlteredMeshes","computeBoundingSphere","progressMessage","meshNames","LoadedMeshUserOverride","disregardMesh","alteredMesh","addMesh","MaterialHandler","onLoadMaterials","createDefaultMaterials","overrideExisting","defaultMaterial","color","defaultVertexColorMaterial","defaultLineMaterial","defaultPointMaterial","size","runtimeMaterials","addMaterials","addPayloadMaterials","materialPayload","newMaterials","clone","serializedMaterials","materialJson","loader","parse","existingMaterial","add","getMaterials","getMaterialsJSON","materialsJSON","toJSON","clearMaterials","OBJLoader2","manager","call","parser","modelName","instanceNo","baseObject3d","meshReceiver","defaultOnAssetAvailable","OBJLOADER2_VERSION","create","setModelName","setBaseObject3d","setCallbackOnMeshAlter","setCallbackOnLoadMaterials","load","url","onFileLoadProgress","event","currentTarget","statusText","responseURL","urlFull","URL","window","location","href","filename","urlParts","split","path","slice","numericalValueRef","lengthComputable","loaded","total","output","fileLoaderOnLoad","fileLoader","setPath","resourcePath","setResponseType","ArrayBuffer"],"mappings":"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","file":"js/chunk-2d0d2ae6.6673f89d.js","sourcesContent":["/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n/**\n * Parse OBJ data either from ArrayBuffer or string\n */\nconst OBJLoader2Parser = function () {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tlet scope = this;\n\tthis.callbacks = {\n\t\tonProgress: function ( text ) {\n\n\t\t\tscope._onProgress( text );\n\n\t\t},\n\t\tonAssetAvailable: function ( payload ) {\n\n\t\t\tscope._onAssetAvailable( payload );\n\n\t\t},\n\t\tonError: function ( errorMessage ) {\n\n\t\t\tscope._onError( errorMessage );\n\n\t\t},\n\t\tonLoad: function ( object3d, message ) {\n\n\t\t\tscope._onLoad( object3d, message );\n\n\t\t},\n\t};\n\tthis.contentRef = null;\n\tthis.legacyMode = false;\n\n\tthis.materials = {};\n\tthis.materialPerSmoothingGroup = false;\n\tthis.useOAsMesh = false;\n\tthis.useIndices = false;\n\tthis.disregardNormals = false;\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.normals = [];\n\tthis.uvs = [];\n\n\tthis.rawMesh = {\n\t\tobjectName: '',\n\t\tgroupName: '',\n\t\tactiveMtlName: '',\n\t\tmtllibName: '',\n\n\t\t// reset with new mesh\n\t\tfaceType: - 1,\n\t\tsubGroups: [],\n\t\tsubGroupInUse: null,\n\t\tsmoothingGroup: {\n\t\t\tsplitMaterials: false,\n\t\t\tnormalized: - 1,\n\t\t\treal: - 1\n\t\t},\n\t\tcounts: {\n\t\t\tdoubleIndicesCount: 0,\n\t\t\tfaceCount: 0,\n\t\t\tmtlCount: 0,\n\t\t\tsmoothingGroupCount: 0\n\t\t}\n\t};\n\n\tthis.inputObjectCount = 1;\n\tthis.outputObjectCount = 1;\n\tthis.globalCounts = {\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tdoubleIndicesCount: 0,\n\t\tlineByte: 0,\n\t\tcurrentByte: 0,\n\t\ttotalBytes: 0\n\t};\n\n};\n\nOBJLoader2Parser.prototype = {\n\n\tconstructor: OBJLoader2Parser,\n\n\t_resetRawMesh: function () {\n\n\t\t// faces are stored according combined index of group, material and smoothingGroup (0 or not)\n\t\tthis.rawMesh.subGroups = [];\n\t\tthis.rawMesh.subGroupInUse = null;\n\t\tthis.rawMesh.smoothingGroup.normalized = - 1;\n\t\tthis.rawMesh.smoothingGroup.real = - 1;\n\n\t\t// this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\t\tthis._pushSmoothingGroup( 1 );\n\n\t\tthis.rawMesh.counts.doubleIndicesCount = 0;\n\t\tthis.rawMesh.counts.faceCount = 0;\n\t\tthis.rawMesh.counts.mtlCount = 0;\n\t\tthis.rawMesh.counts.smoothingGroupCount = 0;\n\n\t},\n\n\t/**\n\t * Tells whether a material shall be created per smoothing group.\n\t *\n\t * @param {boolean} materialPerSmoothingGroup=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {\n\n\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of \"o\" can be enforced.\n\t *\n\t * @param {boolean} useOAsMesh=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseOAsMesh: function ( useOAsMesh ) {\n\n\t\tthis.useOAsMesh = useOAsMesh === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Instructs loaders to create indexed {@link BufferGeometry}.\n\t *\n\t * @param {boolean} useIndices=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseIndices: function ( useIndices ) {\n\n\t\tthis.useIndices = useIndices === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Tells whether normals should be completely disregarded and regenerated.\n\t *\n\t * @param {boolean} disregardNormals=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetDisregardNormals: function ( disregardNormals ) {\n\n\t\tthis.disregardNormals = disregardNormals === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Clears materials object and sets the new ones.\n\t *\n\t * @param {Object} materials Object with named materials\n\t */\n\tsetMaterials: function ( materials ) {\n\n \t\tthis.materials = Object.assign( {}, materials );\n\n\t},\n\n\t/**\n\t * Register a function that is called once an asset (mesh/material) becomes available.\n\t *\n\t * @param onAssetAvailable\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnAssetAvailable: function ( onAssetAvailable ) {\n\n\t\tif ( onAssetAvailable !== null && onAssetAvailable !== undefined && onAssetAvailable instanceof Function ) {\n\n\t\t\tthis.callbacks.onAssetAvailable = onAssetAvailable;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is used to report overall processing progress.\n\t *\n\t * @param {Function} onProgress\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnProgress: function ( onProgress ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.\n\t *\n\t * @param {Function} onError\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnError: function ( onError ) {\n\n\t\tif ( onError !== null && onError !== undefined && onError instanceof Function ) {\n\n\t\t\tthis.callbacks.onError = onError;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called when parsing was completed.\n\t *\n\t * @param {Function} onLoad\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnLoad: function ( onLoad ) {\n\n\t\tif ( onLoad !== null && onLoad !== undefined && onLoad instanceof Function ) {\n\n\t\t\tthis.callbacks.onLoad = onLoad;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Announce parse progress feedback which is logged to the console.\n\t * @private\n\t *\n\t * @param {string} text Textual description of the event\n\t */\n\t_onProgress: function ( text ) {\n\n\t\tlet message = text ? text : '';\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Announce error feedback which is logged as error message.\n\t * @private\n\t *\n\t * @param {String} errorMessage The event containing the error\n\t */\n\t_onError: function ( errorMessage ) {\n\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.error( errorMessage );\n\n\t\t}\n\n\t},\n\n\t_onAssetAvailable: function ( payload ) {\n\n\t\tlet errorMessage = 'OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...';\n\t\tthis.callbacks.onError( errorMessage );\n\t\tthrow errorMessage;\n\n\t},\n\n\t_onLoad: function ( object3d, message ) {\n\n\t\tconsole.log( \"You reached parser default onLoad callback: \" + message );\n\n\t},\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t *\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetLogging: function ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\treturn this;\n\n\t},\n\n\t_configure: function () {\n\n\t\tthis._pushSmoothingGroup( 1 );\n\t\tif ( this.logging.enabled ) {\n\n\t\t\tlet matKeys = Object.keys( this.materials );\n\t\t\tlet matNames = ( matKeys.length > 0 ) ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join( '\\n\\t\\t- ' ) : '\\n\\tmaterialNames: None';\n\t\t\tlet printedConfig = 'OBJLoader.Parser configuration:'\n\t\t\t\t+ matNames\n\t\t\t\t+ '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup\n\t\t\t\t+ '\\n\\tuseOAsMesh: ' + this.useOAsMesh\n\t\t\t\t+ '\\n\\tuseIndices: ' + this.useIndices\n\t\t\t\t+ '\\n\\tdisregardNormals: ' + this.disregardNormals;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onProgress: ' + this.callbacks.onProgress.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onAssetAvailable: ' + this.callbacks.onAssetAvailable.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onError: ' + this.callbacks.onError.name;\n\t\t\tconsole.info( printedConfig );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Parse the provided arraybuffer\n\t *\n\t * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n\t */\n\texecute: function ( arrayBuffer ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.execute' );\n\t\tthis._configure();\n\n\t\tlet arrayBufferView = new Uint8Array( arrayBuffer );\n\t\tthis.contentRef = arrayBufferView;\n\t\tlet length = arrayBufferView.byteLength;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tlet buffer = new Array( 128 );\n\n\t\tlet bufferPointer = 0;\n\t\tlet slashesCount = 0;\n\t\tlet word = '';\n\t\tlet currentByte = 0;\n\t\tfor ( let code, currentByte = 0; currentByte < length; currentByte ++ ) {\n\n\t\t\tcode = arrayBufferView[ currentByte ];\n\t\t\tswitch ( code ) {\n\n\t\t\t\t// space\n\t\t\t\tcase 32:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\t\t\t\t// slash\n\t\t\t\tcase 47:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LF\n\t\t\t\tcase 10:\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\t\t\t\tword = '';\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// CR\n\t\t\t\tcase 13:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += String.fromCharCode( code );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.execute' );\n\n\t},\n\n\t/**\n\t * Parse the provided text\n\t *\n\t * @param {string} text OBJ data as string\n\t */\n\texecuteLegacy: function ( text ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.executeLegacy' );\n\t\tthis._configure();\n\t\tthis.legacyMode = true;\n\t\tthis.contentRef = text;\n\t\tlet length = text.length;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tlet buffer = new Array( 128 );\n\n\t\tlet bufferPointer = 0;\n\t\tlet slashesCount = 0;\n\t\tlet word = '';\n\t\tlet currentByte = 0;\n\t\tfor ( let char; currentByte < length; currentByte ++ ) {\n\n\t\t\tchar = text[ currentByte ];\n\t\t\tswitch ( char ) {\n\n\t\t\t\tcase ' ':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '/':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\n':\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\t\t\t\tword = '';\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\r':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += char;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._processLine( buffer, bufferPointer, word, slashesCount );\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.executeLegacy' );\n\n\t},\n\n\t_processLine: function ( buffer, bufferPointer, slashesCount, word, currentByte ) {\n\n\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\tthis.globalCounts.currentByte = currentByte;\n\t\tif ( bufferPointer < 1 ) return;\n\n\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\n\t\tlet reconstructString = function ( content, legacyMode, start, stop ) {\n\n\t\t\tlet line = '';\n\t\t\tif ( stop > start ) {\n\n\t\t\t\tlet i;\n\t\t\t\tif ( legacyMode ) {\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += content[ i ];\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += String.fromCharCode( content[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tline = line.trim();\n\n\t\t\t}\n\n\t\t\treturn line;\n\n\t\t};\n\n\t\tlet bufferLength, length, i, lineDesignation;\n\t\tlineDesignation = buffer[ 0 ];\n\t\tswitch ( lineDesignation ) {\n\n\t\t\tcase 'v':\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tif ( bufferPointer > 4 ) {\n\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 4 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 5 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 6 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'vt':\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'vn':\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\n\t\t\t\t// \"f vertex ...\"\n\t\t\t\tif ( slashesCount === 0 ) {\n\n\t\t\t\t\tthis._checkFaceType( 0 );\n\t\t\t\t\tfor ( i = 2, length = bufferLength; i < length; i ++ ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv ...\"\n\n\t\t\t\t} else if ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 1 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv/normal ...\"\n\n\t\t\t\t} else if ( bufferLength * 2 === slashesCount * 3 ) {\n\n\t\t\t\t\tthis._checkFaceType( 2 );\n\t\t\t\t\tfor ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex//normal ...\"\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( 3 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\tcase 'p':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\t\t\t\tif ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 4 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i += 2 ) this._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( ( lineDesignation === 'l' ) ? 5 : 6 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i ++ ) this._buildFace( buffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tthis._pushSmoothingGroup( buffer[ 1 ] );\n\t\t\t\tbreak;\n\n\t\t\tcase 'g':\n\t\t\t\t// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n\t\t\t\tthis._processCompletedMesh();\n\t\t\t\tthis.rawMesh.groupName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'o':\n\t\t\t\t// 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\n\t\t\t\tif ( this.useOAsMesh ) this._processCompletedMesh();\n\t\t\t\tthis.rawMesh.objectName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'mtllib':\n\t\t\t\tthis.rawMesh.mtllibName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'usemtl':\n\t\t\t\tlet mtlName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tif ( mtlName !== '' && this.rawMesh.activeMtlName !== mtlName ) {\n\n\t\t\t\t\tthis.rawMesh.activeMtlName = mtlName;\n\t\t\t\t\tthis.rawMesh.counts.mtlCount ++;\n\t\t\t\t\tthis._checkSubGroup();\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t}\n\n\t},\n\n\t_pushSmoothingGroup: function ( smoothingGroup ) {\n\n\t\tlet smoothingGroupInt = parseInt( smoothingGroup );\n\t\tif ( isNaN( smoothingGroupInt ) ) {\n\n\t\t\tsmoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n\n\t\t}\n\n\t\tlet smoothCheck = this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;\n\t\tthis.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n\t\tif ( smoothCheck !== smoothingGroupInt ) {\n\n\t\t\tthis.rawMesh.counts.smoothingGroupCount ++;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Expanded faceTypes include all four face types, both line types and the point type\n\t * faceType = 0: \"f vertex ...\"\n\t * faceType = 1: \"f vertex/uv ...\"\n\t * faceType = 2: \"f vertex/uv/normal ...\"\n\t * faceType = 3: \"f vertex//normal ...\"\n\t * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n\t * faceType = 5: \"l vertex ...\"\n\t * faceType = 6: \"p vertex ...\"\n\t */\n\t_checkFaceType: function ( faceType ) {\n\n\t\tif ( this.rawMesh.faceType !== faceType ) {\n\n\t\t\tthis._processCompletedMesh();\n\t\t\tthis.rawMesh.faceType = faceType;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t_checkSubGroup: function () {\n\n\t\tlet index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.subGroupInUse = this.rawMesh.subGroups[ index ];\n\n\t\tif ( this.rawMesh.subGroupInUse === undefined || this.rawMesh.subGroupInUse === null ) {\n\n\t\t\tthis.rawMesh.subGroupInUse = {\n\t\t\t\tindex: index,\n\t\t\t\tobjectName: this.rawMesh.objectName,\n\t\t\t\tgroupName: this.rawMesh.groupName,\n\t\t\t\tmaterialName: this.rawMesh.activeMtlName,\n\t\t\t\tsmoothingGroup: this.rawMesh.smoothingGroup.normalized,\n\t\t\t\tvertices: [],\n\t\t\t\tindexMappingsCount: 0,\n\t\t\t\tindexMappings: [],\n\t\t\t\tindices: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\t\t\t\tnormals: []\n\t\t\t};\n\t\t\tthis.rawMesh.subGroups[ index ] = this.rawMesh.subGroupInUse;\n\n\t\t}\n\n\t},\n\n\t_buildFace: function ( faceIndexV, faceIndexU, faceIndexN ) {\n\n\t\tlet subGroupInUse = this.rawMesh.subGroupInUse;\n\t\tlet scope = this;\n\t\tlet updateSubGroupInUse = function () {\n\n\t\t\tlet faceIndexVi = parseInt( faceIndexV );\n\t\t\tlet indexPointerV = 3 * ( faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3 );\n\t\t\tlet indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n\n\t\t\tlet vertices = subGroupInUse.vertices;\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ] );\n\n\t\t\tif ( indexPointerC !== null ) {\n\n\t\t\t\tlet colors = subGroupInUse.colors;\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ] );\n\n\t\t\t}\n\n\t\t\tif ( faceIndexU ) {\n\n\t\t\t\tlet faceIndexUi = parseInt( faceIndexU );\n\t\t\t\tlet indexPointerU = 2 * ( faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2 );\n\t\t\t\tlet uvs = subGroupInUse.uvs;\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ++ ] );\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ] );\n\n\t\t\t}\n\n\t\t\tif ( faceIndexN && ! scope.disregardNormals ) {\n\n\t\t\t\tlet faceIndexNi = parseInt( faceIndexN );\n\t\t\t\tlet indexPointerN = 3 * ( faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3 );\n\t\t\t\tlet normals = subGroupInUse.normals;\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( this.useIndices ) {\n\n\t\t\tif ( this.disregardNormals ) faceIndexN = undefined;\n\t\t\tlet mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );\n\t\t\tlet indicesPointer = subGroupInUse.indexMappings[ mappingName ];\n\t\t\tif ( indicesPointer === undefined || indicesPointer === null ) {\n\n\t\t\t\tindicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n\t\t\t\tupdateSubGroupInUse();\n\t\t\t\tsubGroupInUse.indexMappings[ mappingName ] = indicesPointer;\n\t\t\t\tsubGroupInUse.indexMappingsCount ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.rawMesh.counts.doubleIndicesCount ++;\n\n\t\t\t}\n\n\t\t\tsubGroupInUse.indices.push( indicesPointer );\n\n\t\t} else {\n\n\t\t\tupdateSubGroupInUse();\n\n\t\t}\n\n\t\tthis.rawMesh.counts.faceCount ++;\n\n\t},\n\n\t_createRawMeshReport: function ( inputObjectCount ) {\n\n\t\treturn 'Input Object number: ' + inputObjectCount +\n\t\t\t'\\n\\tObject name: ' + this.rawMesh.objectName +\n\t\t\t'\\n\\tGroup name: ' + this.rawMesh.groupName +\n\t\t\t'\\n\\tMtllib name: ' + this.rawMesh.mtllibName +\n\t\t\t'\\n\\tVertex count: ' + this.vertices.length / 3 +\n\t\t\t'\\n\\tNormal count: ' + this.normals.length / 3 +\n\t\t\t'\\n\\tUV count: ' + this.uvs.length / 2 +\n\t\t\t'\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount +\n\t\t\t'\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount +\n\t\t\t'\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n\n\t},\n\n\t/**\n\t * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n\t */\n\t_finalizeRawMesh: function () {\n\n\t\tlet meshOutputGroupTemp = [];\n\t\tlet meshOutputGroup;\n\t\tlet absoluteVertexCount = 0;\n\t\tlet absoluteIndexMappingsCount = 0;\n\t\tlet absoluteIndexCount = 0;\n\t\tlet absoluteColorCount = 0;\n\t\tlet absoluteNormalCount = 0;\n\t\tlet absoluteUvCount = 0;\n\t\tlet indices;\n\t\tfor ( let name in this.rawMesh.subGroups ) {\n\n\t\t\tmeshOutputGroup = this.rawMesh.subGroups[ name ];\n\t\t\tif ( meshOutputGroup.vertices.length > 0 ) {\n\n\t\t\t\tindices = meshOutputGroup.indices;\n\t\t\t\tif ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = indices[ i ] + absoluteIndexMappingsCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmeshOutputGroupTemp.push( meshOutputGroup );\n\t\t\t\tabsoluteVertexCount += meshOutputGroup.vertices.length;\n\t\t\t\tabsoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n\t\t\t\tabsoluteIndexCount += meshOutputGroup.indices.length;\n\t\t\t\tabsoluteColorCount += meshOutputGroup.colors.length;\n\t\t\t\tabsoluteUvCount += meshOutputGroup.uvs.length;\n\t\t\t\tabsoluteNormalCount += meshOutputGroup.normals.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do not continue if no result\n\t\tlet result = null;\n\t\tif ( meshOutputGroupTemp.length > 0 ) {\n\n\t\t\tresult = {\n\t\t\t\tname: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n\t\t\t\tsubGroups: meshOutputGroupTemp,\n\t\t\t\tabsoluteVertexCount: absoluteVertexCount,\n\t\t\t\tabsoluteIndexCount: absoluteIndexCount,\n\t\t\t\tabsoluteColorCount: absoluteColorCount,\n\t\t\t\tabsoluteNormalCount: absoluteNormalCount,\n\t\t\t\tabsoluteUvCount: absoluteUvCount,\n\t\t\t\tfaceCount: this.rawMesh.counts.faceCount,\n\t\t\t\tdoubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t_processCompletedMesh: function () {\n\n\t\tlet result = this._finalizeRawMesh();\n\t\tlet haveMesh = result !== null;\n\t\tif ( haveMesh ) {\n\n\t\t\tif ( this.colors.length > 0 && this.colors.length !== this.vertices.length ) {\n\n\t\t\t\tthis.callbacks.onError( 'Vertex Colors were detected, but vertex count and color count do not match!' );\n\n\t\t\t}\n\n\t\t\tif ( this.logging.enabled && this.logging.debug ) console.debug( this._createRawMeshReport( this.inputObjectCount ) );\n\t\t\tthis.inputObjectCount ++;\n\n\t\t\tthis._buildMesh( result );\n\t\t\tlet progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\t\t\tthis._onProgress( 'Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '' +\n\t\t\t\t'] Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%' );\n\t\t\tthis._resetRawMesh();\n\n\t\t}\n\n\t\treturn haveMesh;\n\n\t},\n\n\t/**\n\t * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.\n\t * It is ensured that SubGroups only contain objects with vertices (no need to check).\n\t *\n\t * @param result\n\t */\n\t_buildMesh: function ( result ) {\n\n\t\tlet meshOutputGroups = result.subGroups;\n\n\t\tlet vertexFA = new Float32Array( result.absoluteVertexCount );\n\t\tthis.globalCounts.vertices += result.absoluteVertexCount / 3;\n\t\tthis.globalCounts.faces += result.faceCount;\n\t\tthis.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n\t\tlet indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;\n\t\tlet colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;\n\t\tlet normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;\n\t\tlet uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;\n\t\tlet haveVertexColors = colorFA !== null;\n\n\t\tlet meshOutputGroup;\n\t\tlet materialNames = [];\n\n\t\tlet createMultiMaterial = ( meshOutputGroups.length > 1 );\n\t\tlet materialIndex = 0;\n\t\tlet materialIndexMapping = [];\n\t\tlet selectedMaterialIndex;\n\t\tlet materialGroup;\n\t\tlet materialGroups = [];\n\n\t\tlet vertexFAOffset = 0;\n\t\tlet indexUAOffset = 0;\n\t\tlet colorFAOffset = 0;\n\t\tlet normalFAOffset = 0;\n\t\tlet uvFAOffset = 0;\n\t\tlet materialGroupOffset = 0;\n\t\tlet materialGroupLength = 0;\n\n\t\tlet materialOrg, material, materialName, materialNameOrg;\n\t\t// only one specific face type\n\t\tfor ( let oodIndex in meshOutputGroups ) {\n\n\t\t\tif ( ! meshOutputGroups.hasOwnProperty( oodIndex ) ) continue;\n\t\t\tmeshOutputGroup = meshOutputGroups[ oodIndex ];\n\n\t\t\tmaterialNameOrg = meshOutputGroup.materialName;\n\t\t\tif ( this.rawMesh.faceType < 4 ) {\n\n\t\t\t\tmaterialName = materialNameOrg + ( haveVertexColors ? '_vertexColor' : '' ) + ( meshOutputGroup.smoothingGroup === 0 ? '_flat' : '' );\n\n\n\t\t\t} else {\n\n\t\t\t\tmaterialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n\n\t\t\t}\n\n\t\t\tmaterialOrg = this.materials[ materialNameOrg ];\n\t\t\tmaterial = this.materials[ materialName ];\n\n\t\t\t// both original and derived names do not lead to an existing material => need to use a default material\n\t\t\tif ( ( materialOrg === undefined || materialOrg === null ) && ( material === undefined || material === null ) ) {\n\n\t\t\t\tmaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n\t\t\t\tmaterial = this.materials[ materialName ];\n\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\tconsole.info( 'object_group \"' + meshOutputGroup.objectName + '_' +\n\t\t\t\t\t\tmeshOutputGroup.groupName + '\" was defined with unresolvable material \"' +\n\t\t\t\t\t\tmaterialNameOrg + '\"! Assigning \"' + materialName + '\".' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material === undefined || material === null ) {\n\n\t\t\t\tlet materialCloneInstructions = {\n\t\t\t\t\tmaterialNameOrg: materialNameOrg,\n\t\t\t\t\tmaterialName: materialName,\n\t\t\t\t\tmaterialProperties: {\n\t\t\t\t\t\tvertexColors: haveVertexColors ? 2 : 0,\n\t\t\t\t\t\tflatShading: meshOutputGroup.smoothingGroup === 0\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlet payload = {\n\t\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tmaterials: {\n\t\t\t\t\t\tmaterialCloneInstructions: materialCloneInstructions\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.callbacks.onAssetAvailable( payload );\n\n\t\t\t\t// only set materials if they don't exist, yet\n\t\t\t\tlet matCheck = this.materials[ materialName ];\n\t\t\t\tif ( matCheck === undefined || matCheck === null ) {\n\n\t\t\t\t\tthis.materials[ materialName ] = materialCloneInstructions;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( createMultiMaterial ) {\n\n\t\t\t\t// re-use material if already used before. Reduces materials array size and eliminates duplicates\n\t\t\t\tselectedMaterialIndex = materialIndexMapping[ materialName ];\n\t\t\t\tif ( ! selectedMaterialIndex ) {\n\n\t\t\t\t\tselectedMaterialIndex = materialIndex;\n\t\t\t\t\tmaterialIndexMapping[ materialName ] = materialIndex;\n\t\t\t\t\tmaterialNames.push( materialName );\n\t\t\t\t\tmaterialIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tmaterialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n\t\t\t\tmaterialGroup = {\n\t\t\t\t\tstart: materialGroupOffset,\n\t\t\t\t\tcount: materialGroupLength,\n\t\t\t\t\tindex: selectedMaterialIndex\n\t\t\t\t};\n\t\t\t\tmaterialGroups.push( materialGroup );\n\t\t\t\tmaterialGroupOffset += materialGroupLength;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialNames.push( materialName );\n\n\t\t\t}\n\n\t\t\tvertexFA.set( meshOutputGroup.vertices, vertexFAOffset );\n\t\t\tvertexFAOffset += meshOutputGroup.vertices.length;\n\n\t\t\tif ( indexUA ) {\n\n\t\t\t\tindexUA.set( meshOutputGroup.indices, indexUAOffset );\n\t\t\t\tindexUAOffset += meshOutputGroup.indices.length;\n\n\t\t\t}\n\n\t\t\tif ( colorFA ) {\n\n\t\t\t\tcolorFA.set( meshOutputGroup.colors, colorFAOffset );\n\t\t\t\tcolorFAOffset += meshOutputGroup.colors.length;\n\n\t\t\t}\n\n\t\t\tif ( normalFA ) {\n\n\t\t\t\tnormalFA.set( meshOutputGroup.normals, normalFAOffset );\n\t\t\t\tnormalFAOffset += meshOutputGroup.normals.length;\n\n\t\t\t}\n\n\t\t\tif ( uvFA ) {\n\n\t\t\t\tuvFA.set( meshOutputGroup.uvs, uvFAOffset );\n\t\t\t\tuvFAOffset += meshOutputGroup.uvs.length;\n\n\t\t\t}\n\n\t\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\t\tlet materialIndexLine = '';\n\t\t\t\tif ( selectedMaterialIndex ) {\n\n\t\t\t\t\tmaterialIndexLine = '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex;\n\n\t\t\t\t}\n\n\t\t\t\tlet createdReport = '\\tOutput Object no.: ' + this.outputObjectCount +\n\t\t\t\t\t'\\n\\t\\tgroupName: ' + meshOutputGroup.groupName +\n\t\t\t\t\t'\\n\\t\\tIndex: ' + meshOutputGroup.index +\n\t\t\t\t\t'\\n\\t\\tfaceType: ' + this.rawMesh.faceType +\n\t\t\t\t\t'\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName +\n\t\t\t\t\t'\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup +\n\t\t\t\t\tmaterialIndexLine +\n\t\t\t\t\t'\\n\\t\\tobjectName: ' + meshOutputGroup.objectName +\n\t\t\t\t\t'\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#indices: ' + meshOutputGroup.indices.length +\n\t\t\t\t\t'\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 +\n\t\t\t\t\t'\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n\t\t\t\tconsole.debug( createdReport );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.outputObjectCount ++;\n\t\tthis.callbacks.onAssetAvailable(\n\t\t\t{\n\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\ttype: 'mesh',\n\t\t\t\tprogress: {\n\t\t\t\t\tnumericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n\t\t\t\t},\n\t\t\t\tparams: {\n\t\t\t\t\tmeshName: result.name\n\t\t\t\t},\n\t\t\t\tmaterials: {\n\t\t\t\t\tmultiMaterial: createMultiMaterial,\n\t\t\t\t\tmaterialNames: materialNames,\n\t\t\t\t\tmaterialGroups: materialGroups\n\t\t\t\t},\n\t\t\t\tbuffers: {\n\t\t\t\t\tvertices: vertexFA,\n\t\t\t\t\tindices: indexUA,\n\t\t\t\t\tcolors: colorFA,\n\t\t\t\t\tnormals: normalFA,\n\t\t\t\t\tuvs: uvFA\n\t\t\t\t},\n\t\t\t\t// 0: mesh, 1: line, 2: point\n\t\t\t\tgeometryType: this.rawMesh.faceType < 4 ? 0 : ( this.rawMesh.faceType === 6 ) ? 2 : 1\n\t\t\t},\n\t\t\t[ vertexFA.buffer ],\n\t\t\tindexUA !== null ? [ indexUA.buffer ] : null,\n\t\t\tcolorFA !== null ? [ colorFA.buffer ] : null,\n\t\t\tnormalFA !== null ? [ normalFA.buffer ] : null,\n\t\t\tuvFA !== null ? [ uvFA.buffer ] : null\n\t\t);\n\n\t},\n\n\t_finalizeParsing: function () {\n\n\t\tif ( this.logging.enabled ) console.info( 'Global output object count: ' + this.outputObjectCount );\n\t\tif ( this._processCompletedMesh() && this.logging.enabled ) {\n\n\t\t\tlet parserFinalReport = 'Overall counts: ' +\n\t\t\t\t'\\n\\tVertices: ' + this.globalCounts.vertices +\n\t\t\t\t'\\n\\tFaces: ' + this.globalCounts.faces +\n\t\t\t\t'\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n\t\t\tconsole.info( parserFinalReport );\n\n\t\t}\n\n\t}\n};\n\nexport { OBJLoader2Parser };\n","/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\nimport {\n\tBufferAttribute,\n\tBufferGeometry,\n\tLineSegments,\n\tMesh,\n\tPoints\n} from \"../../../../../build/three.module.js\";\n\n\n/**\n *\n * @param {MaterialHandler} materialHandler\n * @constructor\n */\nconst MeshReceiver = function ( materialHandler ) {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tthis.callbacks = {\n\t\tonProgress: null,\n\t\tonMeshAlter: null\n\t};\n\tthis.materialHandler = materialHandler;\n\n};\n\nMeshReceiver.prototype = {\n\n\tconstructor: MeshReceiver,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging:\tfunction ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\n\t},\n\n\t/**\n\t *\n\t * @param {Function} onProgress\n\t * @param {Function} onMeshAlter\n\t * @private\n\t */\n\t_setCallbacks: function ( onProgress, onMeshAlter ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\n\t\tif ( onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function ) {\n\n\t\t\tthis.callbacks.onMeshAlter = onMeshAlter;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n\t *\n\t * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n\t * @returns {Mesh[]} mesh Array of {@link Mesh}\n\t */\n\tbuildMeshes: function ( meshPayload ) {\n\n\t\tlet meshName = meshPayload.params.meshName;\n\t\tlet buffers = meshPayload.buffers;\n\n\t\tlet bufferGeometry = new BufferGeometry();\n\t\tif ( buffers.vertices !== undefined && buffers.vertices !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( buffers.vertices ), 3 ) );\n\n\t\t}\n\n\t\tif ( buffers.indices !== undefined && buffers.indices !== null ) {\n\n\t\t\tbufferGeometry.setIndex( new BufferAttribute( new Uint32Array( buffers.indices ), 1 ) );\n\n\t\t}\n\n\t\tif ( buffers.colors !== undefined && buffers.colors !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'color', new BufferAttribute( new Float32Array( buffers.colors ), 3 ) );\n\n\t\t}\n\n\t\tif ( buffers.normals !== undefined && buffers.normals !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( buffers.normals ), 3 ) );\n\n\t\t} else {\n\n\t\t\tbufferGeometry.computeVertexNormals();\n\n\t\t}\n\n\t\tif ( buffers.uvs !== undefined && buffers.uvs !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( buffers.uvs ), 2 ) );\n\n\t\t}\n\n\t\tif ( buffers.skinIndex !== undefined && buffers.skinIndex !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinIndex', new BufferAttribute( new Uint16Array( buffers.skinIndex ), 4 ) );\n\n\t\t}\n\n\t\tif ( buffers.skinWeight !== undefined && buffers.skinWeight !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinWeight', new BufferAttribute( new Float32Array( buffers.skinWeight ), 4 ) );\n\n\t\t}\n\n\t\tlet material, materialName, key;\n\t\tlet materialNames = meshPayload.materials.materialNames;\n\t\tlet createMultiMaterial = meshPayload.materials.multiMaterial;\n\t\tlet multiMaterials = [];\n\n\t\tfor ( key in materialNames ) {\n\n\t\t\tmaterialName = materialNames[ key ];\n\t\t\tmaterial = this.materialHandler.getMaterial( materialName );\n\t\t\tif ( createMultiMaterial ) multiMaterials.push( material );\n\n\t\t}\n\n\t\tif ( createMultiMaterial ) {\n\n\t\t\tmaterial = multiMaterials;\n\t\t\tlet materialGroups = meshPayload.materials.materialGroups;\n\t\t\tlet materialGroup;\n\t\t\tfor ( key in materialGroups ) {\n\n\t\t\t\tmaterialGroup = materialGroups[ key ];\n\t\t\t\tbufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet meshes = [];\n\t\tlet mesh;\n\t\tlet callbackOnMeshAlterResult;\n\t\tlet useOrgMesh = true;\n\t\tlet geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n\n\t\tif ( this.callbacks.onMeshAlter ) {\n\n\t\t\tcallbackOnMeshAlterResult = this.callbacks.onMeshAlter(\n\t\t\t\t{\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tmeshName: meshName,\n\t\t\t\t\t\tbufferGeometry: bufferGeometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tgeometryType: geometryType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\t// here LoadedMeshUserOverride is required to be provided by the callback used to alter the results\n\t\tif ( callbackOnMeshAlterResult ) {\n\n\t\t\tif ( callbackOnMeshAlterResult.isDisregardMesh() ) {\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t} else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {\n\n\t\t\t\tfor ( let i in callbackOnMeshAlterResult.meshes ) {\n\n\t\t\t\t\tmeshes.push( callbackOnMeshAlterResult.meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( useOrgMesh ) {\n\n\t\t\tif ( meshPayload.computeBoundingSphere ) bufferGeometry.computeBoundingSphere();\n\t\t\tif ( geometryType === 0 ) {\n\n\t\t\t\tmesh = new Mesh( bufferGeometry, material );\n\n\t\t\t} else if ( geometryType === 1 ) {\n\n\t\t\t\tmesh = new LineSegments( bufferGeometry, material );\n\n\t\t\t} else {\n\n\t\t\t\tmesh = new Points( bufferGeometry, material );\n\n\t\t\t}\n\n\t\t\tmesh.name = meshName;\n\t\t\tmeshes.push( mesh );\n\n\t\t}\n\n\t\tlet progressMessage = meshPayload.params.meshName;\n\t\tif ( meshes.length > 0 ) {\n\n\t\t\tlet meshNames = [];\n\t\t\tfor ( let i in meshes ) {\n\n\t\t\t\tmesh = meshes[ i ];\n\t\t\t\tmeshNames[ i ] = mesh.name;\n\n\t\t\t}\n\n\t\t\tprogressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t} else {\n\n\t\t\tprogressMessage += ': Not adding mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t}\n\n\t\tif ( this.callbacks.onProgress ) {\n\n\t\t\tthis.callbacks.onProgress( 'progress', progressMessage, meshPayload.progress.numericalValue );\n\n\t\t}\n\n\t\treturn meshes;\n\n\t}\n\n};\n\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nconst LoadedMeshUserOverride = function ( disregardMesh, alteredMesh ) {\n\n\tthis.disregardMesh = disregardMesh === true;\n\tthis.alteredMesh = alteredMesh === true;\n\tthis.meshes = [];\n\n};\n\n\nLoadedMeshUserOverride.prototype = {\n\n\tconstructor: LoadedMeshUserOverride,\n\n\t/**\n\t * Add a mesh created within callback.\n\t *\n\t * @param {Mesh} mesh\n\t */\n\taddMesh: function ( mesh ) {\n\n\t\tthis.meshes.push( mesh );\n\t\tthis.alteredMesh = true;\n\n\t},\n\n\t/**\n\t * Answers if mesh shall be disregarded completely.\n\t *\n\t * @returns {boolean}\n\t */\n\tisDisregardMesh: function () {\n\n\t\treturn this.disregardMesh;\n\n\t},\n\n\t/**\n\t * Answers if new mesh(es) were created.\n\t *\n\t * @returns {boolean}\n\t */\n\tprovidesAlteredMeshes: function () {\n\n\t\treturn this.alteredMesh;\n\n\t}\n};\n\nexport {\n\tMeshReceiver,\n\tLoadedMeshUserOverride\n};\n","/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\nimport {\n\tLineBasicMaterial,\n\tMaterialLoader,\n\tMeshStandardMaterial,\n\tPointsMaterial\n} from \"../../../../../build/three.module.js\";\n\n\nconst MaterialHandler = function () {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tthis.callbacks = {\n\t\tonLoadMaterials: null\n\t};\n\tthis.materials = {};\n\n};\n\nMaterialHandler.prototype = {\n\n\tconstructor: MaterialHandler,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging:\tfunction ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\n\t},\n\n\t_setCallbacks: function ( onLoadMaterials ) {\n\n\t\tif ( onLoadMaterials !== undefined && onLoadMaterials !== null && onLoadMaterials instanceof Function ) {\n\n\t\t\tthis.callbacks.onLoadMaterials = onLoadMaterials;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Creates default materials and adds them to the materials object.\n\t *\n\t * @param overrideExisting boolean Override existing material\n\t */\n\tcreateDefaultMaterials: function ( overrideExisting ) {\n\n\t\tlet defaultMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );\n\t\tdefaultMaterial.name = 'defaultMaterial';\n\n\t\tlet defaultVertexColorMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );\n\t\tdefaultVertexColorMaterial.name = 'defaultVertexColorMaterial';\n\t\tdefaultVertexColorMaterial.vertexColors = true;\n\n\t\tlet defaultLineMaterial = new LineBasicMaterial();\n\t\tdefaultLineMaterial.name = 'defaultLineMaterial';\n\n\t\tlet defaultPointMaterial = new PointsMaterial( { size: 0.1 } );\n\t\tdefaultPointMaterial.name = 'defaultPointMaterial';\n\n\t\tlet runtimeMaterials = {};\n\t\truntimeMaterials[ defaultMaterial.name ] = defaultMaterial;\n\t\truntimeMaterials[ defaultVertexColorMaterial.name ] = defaultVertexColorMaterial;\n\t\truntimeMaterials[ defaultLineMaterial.name ] = defaultLineMaterial;\n\t\truntimeMaterials[ defaultPointMaterial.name ] = defaultPointMaterial;\n\n\t\tthis.addMaterials( runtimeMaterials, overrideExisting );\n\n\t},\n\n\t/**\n\t * Updates the materials with contained material objects (sync) or from alteration instructions (async).\n\t *\n\t * @param {Object} materialPayload Material update instructions\n\t * @returns {Object} Map of {@link Material}\n\t */\n\taddPayloadMaterials: function ( materialPayload ) {\n\n\t\tlet material, materialName;\n\t\tlet materialCloneInstructions = materialPayload.materials.materialCloneInstructions;\n\t\tlet newMaterials = {};\n\n\t\tif ( materialCloneInstructions !== undefined && materialCloneInstructions !== null ) {\n\n\t\t\tlet materialNameOrg = materialCloneInstructions.materialNameOrg;\n\t\t\tmaterialNameOrg = ( materialNameOrg !== undefined && materialNameOrg !== null ) ? materialNameOrg : \"\";\n\t\t\tlet materialOrg = this.materials[ materialNameOrg ];\n\t\t\tif ( materialOrg ) {\n\n\t\t\t\tmaterial = materialOrg.clone();\n\n\t\t\t\tmaterialName = materialCloneInstructions.materialName;\n\t\t\t\tmaterial.name = materialName;\n\n\t\t\t\tObject.assign( material, materialCloneInstructions.materialProperties );\n\n\t\t\t\tthis.materials[ materialName ] = material;\n\t\t\t\tnewMaterials[ materialName ] = material;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\tconsole.info( 'Requested material \"' + materialNameOrg + '\" is not available!' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet materials = materialPayload.materials.serializedMaterials;\n\n\t\tif ( materials !== undefined && materials !== null && Object.keys( materials ).length > 0 ) {\n\n\t\t\tlet loader = new MaterialLoader();\n\t\t\tlet materialJson;\n\n\t\t\tfor ( materialName in materials ) {\n\n\t\t\t\tmaterialJson = materials[ materialName ];\n\n\t\t\t\tif ( materialJson !== undefined && materialJson !== null ) {\n\n\t\t\t\t\tmaterial = loader.parse( materialJson );\n\n\t\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\t\tconsole.info( 'De-serialized material with name \"' + materialName + '\" will be added.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.materials[ materialName ] = material;\n\t\t\t\t\tnewMaterials[ materialName ] = material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmaterials = materialPayload.materials.runtimeMaterials;\n\t\tnewMaterials = this.addMaterials( materials, true, newMaterials );\n\n\t\treturn newMaterials;\n\n\t},\n\n\t/**\n\t * Set materials loaded by any supplier of an Array of {@link Material}.\n\t *\n\t * @param materials Object with named {@link Material}\n\t * @param overrideExisting boolean Override existing material\n\t * @param newMaterials [Object] with named {@link Material}\n\t */\n\taddMaterials: function ( materials, overrideExisting, newMaterials ) {\n\n\t\tif ( newMaterials === undefined || newMaterials === null ) {\n\n\t\t\tnewMaterials = {};\n\n\t\t}\n\n\t\tif ( materials !== undefined && materials !== null && Object.keys( materials ).length > 0 ) {\n\n\t\t\tlet material;\n\t\t\tlet existingMaterial;\n\t\t\tlet add;\n\n\t\t\tfor ( let materialName in materials ) {\n\n\t\t\t\tmaterial = materials[ materialName ];\n\t\t\t\tadd = overrideExisting === true;\n\n\t\t\t\tif ( ! add ) {\n\n\t\t\t\t\texistingMaterial = this.materials[ materialName ];\n\t\t\t\t\tadd = ( existingMaterial === null || existingMaterial === undefined );\n\n\t\t\t\t}\n\n\t\t\t\tif ( add ) {\n\n\t\t\t\t\tthis.materials[ materialName ] = material;\n\t\t\t\t\tnewMaterials[ materialName ] = material;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\t\t\tconsole.info( 'Material with name \"' + materialName + '\" was added.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.callbacks.onLoadMaterials ) {\n\n\t\t\tthis.callbacks.onLoadMaterials( newMaterials );\n\n\t\t}\n\n\t\treturn newMaterials;\n\n\t},\n\n\t/**\n\t * Returns the mapping object of material name and corresponding material.\n\t *\n\t * @returns {Object} Map of {@link Material}\n\t */\n\tgetMaterials: function () {\n\n\t\treturn this.materials;\n\n\t},\n\n\t/**\n\t *\n\t * @param {String} materialName\n\t * @returns {Material}\n\t */\n\tgetMaterial: function ( materialName ) {\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\t/**\n\t * Returns the mapping object of material name and corresponding jsonified material.\n\t *\n\t * @returns {Object} Map of Materials in JSON representation\n\t */\n\tgetMaterialsJSON: function () {\n\n\t\tlet materialsJSON = {};\n\t\tlet material;\n\n\t\tfor ( let materialName in this.materials ) {\n\n\t\t\tmaterial = this.materials[ materialName ];\n\t\t\tmaterialsJSON[ materialName ] = material.toJSON();\n\n\t\t}\n\n\t\treturn materialsJSON;\n\n\t},\n\n\t/**\n\t * Removes all materials\n\t */\n\tclearMaterials: function () {\n\n\t\tthis.materials = {};\n\n\t}\n\n};\n\nexport { MaterialHandler };\n","/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\nimport {\n\tFileLoader,\n\tObject3D,\n\tLoader\n} from \"../../../build/three.module.js\";\n\nimport { OBJLoader2Parser } from \"./obj2/OBJLoader2Parser.js\";\nimport { MeshReceiver } from \"./obj2/shared/MeshReceiver.js\";\nimport { MaterialHandler } from \"./obj2/shared/MaterialHandler.js\";\n\n/**\n * Creates a new OBJLoader2. Use it to load OBJ data from files or to parse OBJ data from arraybuffer or text.\n *\n * @param {LoadingManager} [manager] The loadingManager for the loader to use. Default is {@link LoadingManager}\n * @constructor\n */\nconst OBJLoader2 = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n\tthis.parser = new OBJLoader2Parser();\n\n\tthis.modelName = '';\n\tthis.instanceNo = 0;\n\tthis.baseObject3d = new Object3D();\n\n\tthis.materialHandler = new MaterialHandler();\n\tthis.meshReceiver = new MeshReceiver( this.materialHandler );\n\n\t// as OBJLoader2 is no longer derived from OBJLoader2Parser, we need to override the default onAssetAvailable callback\n\tlet scope = this;\n\tlet defaultOnAssetAvailable = function ( payload ) {\n\n\t\tscope._onAssetAvailable( payload );\n\n\t};\n\n\tthis.parser.setCallbackOnAssetAvailable( defaultOnAssetAvailable );\n\n};\n\nOBJLoader2.OBJLOADER2_VERSION = '3.2.0';\nconsole.info( 'Using OBJLoader2 version: ' + OBJLoader2.OBJLOADER2_VERSION );\n\n\nOBJLoader2.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: OBJLoader2,\n\n\t/**\n\t * See {@link OBJLoader2Parser.setLogging}\n\t * @return {OBJLoader2}\n\t */\n\tsetLogging: function ( enabled, debug ) {\n\n\t\tthis.parser.setLogging( enabled, debug );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setMaterialPerSmoothingGroup}\n\t * @return {OBJLoader2}\n\t */\n\tsetMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {\n\n\t\tthis.parser.setMaterialPerSmoothingGroup( materialPerSmoothingGroup );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setUseOAsMesh}\n\t * @return {OBJLoader2}\n\t */\n\tsetUseOAsMesh: function ( useOAsMesh ) {\n\n\t\tthis.parser.setUseOAsMesh( useOAsMesh );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setUseIndices}\n\t * @return {OBJLoader2}\n\t */\n\tsetUseIndices: function ( useIndices ) {\n\n\t\tthis.parser.setUseIndices( useIndices );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setDisregardNormals}\n\t * @return {OBJLoader2}\n\t */\n\tsetDisregardNormals: function ( disregardNormals ) {\n\n\t\tthis.parser.setDisregardNormals( disregardNormals );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Set the name of the model.\n\t *\n\t * @param {string} modelName\n\t * @return {OBJLoader2}\n\t */\n\tsetModelName: function ( modelName ) {\n\n\t\tthis.modelName = modelName ? modelName : this.modelName;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Set the node where the loaded objects will be attached directly.\n\t *\n\t * @param {Object3D} baseObject3d Object already attached to scenegraph where new meshes will be attached to\n\t * @return {OBJLoader2}\n\t */\n\tsetBaseObject3d: function ( baseObject3d ) {\n\n\t\tthis.baseObject3d = ( baseObject3d === undefined || baseObject3d === null ) ? this.baseObject3d : baseObject3d;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Add materials as associated array.\n\t *\n\t * @param {Object} materials Object with named {@link Material}\n\t * @param overrideExisting boolean Override existing material\n\t * @return {OBJLoader2}\n\t */\n\taddMaterials: function ( materials, overrideExisting ) {\n\n\t\tthis.materialHandler.addMaterials( materials, overrideExisting );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnAssetAvailable}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnAssetAvailable: function ( onAssetAvailable ) {\n\n\t\tthis.parser.setCallbackOnAssetAvailable( onAssetAvailable );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnProgress}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnProgress: function ( onProgress ) {\n\n\t\tthis.parser.setCallbackOnProgress( onProgress );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnError}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnError: function ( onError ) {\n\n\t\tthis.parser.setCallbackOnError( onError );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnLoad}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnLoad: function ( onLoad ) {\n\n\t\tthis.parser.setCallbackOnLoad( onLoad );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called once a single mesh is available and it could be altered by the supplied function.\n\t *\n\t * @param {Function} [onMeshAlter]\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnMeshAlter: function ( onMeshAlter ) {\n\n\t\tthis.meshReceiver._setCallbacks( this.parser.callbacks.onProgress, onMeshAlter );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called once all materials have been loaded and they could be altered by the supplied function.\n\t *\n\t * @param {Function} [onLoadMaterials]\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnLoadMaterials: function ( onLoadMaterials ) {\n\n\t\tthis.materialHandler._setCallbacks( onLoadMaterials );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.\n\t *\n\t * @param {string}  url A string containing the path/URL of the file to be loaded.\n\t * @param {function} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.\n\t * @param {function} [onFileLoadProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n\t * @param {function} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n\t * @param {function} [onMeshAlter] Called after every single mesh is made available by the parser\n\t */\n\tload: function ( url, onLoad, onFileLoadProgress, onError, onMeshAlter ) {\n\n\t\tlet scope = this;\n\t\tif ( onLoad === null || onLoad === undefined || ! ( onLoad instanceof Function ) ) {\n\n\t\t\tlet errorMessage = 'onLoad is not a function! Aborting...';\n\t\t\tscope.parser.callbacks.onError( errorMessage );\n\t\t\tthrow errorMessage;\n\n\t\t} else {\n\n\t\t\tthis.parser.setCallbackOnLoad( onLoad );\n\n\t\t}\n\n\t\tif ( onError === null || onError === undefined || ! ( onError instanceof Function ) ) {\n\n\t\t\tonError = function ( event ) {\n\n\t\t\t\tlet errorMessage = event;\n\n\t\t\t\tif ( event.currentTarget && event.currentTarget.statusText !== null ) {\n\n\t\t\t\t\terrorMessage = 'Error occurred while downloading!\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\n\n\t\t\t\t}\n\n\t\t\t\tscope.parser.callbacks.onError( errorMessage );\n\n\t\t\t};\n\n\t\t}\n\n\t\tif ( ! url ) {\n\n\t\t\tonError( 'An invalid url was provided. Unable to continue!' );\n\n\t\t}\n\n\t\tlet urlFull = new URL( url, window.location.href ).href;\n\t\tlet filename = urlFull;\n\t\tlet urlParts = urlFull.split( '/' );\n\t\tif ( urlParts.length > 2 ) {\n\n\t\t\tfilename = urlParts[ urlParts.length - 1 ];\n\t\t\tthis.path = urlParts.slice( 0, urlParts.length - 1 ).join( '/' ) + '/';\n\n\t\t}\n\n\t\tif ( onFileLoadProgress === null || onFileLoadProgress === undefined || ! ( onFileLoadProgress instanceof Function ) ) {\n\n\t\t\tlet numericalValueRef = 0;\n\t\t\tlet numericalValue = 0;\n\t\t\tonFileLoadProgress = function ( event ) {\n\n\t\t\t\tif ( ! event.lengthComputable ) return;\n\n\t\t\t\tnumericalValue = event.loaded / event.total;\n\n\t\t\t\tif ( numericalValue > numericalValueRef ) {\n\n\t\t\t\t\tnumericalValueRef = numericalValue;\n\t\t\t\t\tlet output = 'Download of \"' + url + '\": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';\n\t\t\t\t\tscope.parser.callbacks.onProgress( 'progressLoad', output, numericalValue );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tthis.setCallbackOnMeshAlter( onMeshAlter );\n\t\tlet fileLoaderOnLoad = function ( content ) {\n\n\t\t\tscope.parser.callbacks.onLoad( scope.parse( content ), \"OBJLoader2#load: Parsing completed\" );\n\n\t\t};\n\n\t\tlet fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path || this.resourcePath );\n\t\tfileLoader.setResponseType( 'arraybuffer' );\n\t\tfileLoader.load( filename, fileLoaderOnLoad, onFileLoadProgress, onError );\n\n\t},\n\n\t/**\n\t * Parses OBJ data synchronously from arraybuffer or string and returns the {@link Object3D}.\n\t *\n\t * @param {arraybuffer|string} content OBJ data as Uint8Array or String\n\t * @return {Object3D}\n\t */\n\tparse: function ( content ) {\n\n\t\t// fast-fail in case of illegal data\n\t\tif ( content === null || content === undefined ) {\n\n\t\t\tthrow 'Provided content is not a valid ArrayBuffer or String. Unable to continue parsing';\n\n\t\t}\n\n\t\tif ( this.parser.logging.enabled ) {\n\n\t\t\tconsole.time( 'OBJLoader parse: ' + this.modelName );\n\n\t\t}\n\n\t\t// Create default materials beforehand, but do not override previously set materials (e.g. during init)\n\t\tthis.materialHandler.createDefaultMaterials( false );\n\n\t\t// code works directly on the material references, parser clear its materials before updating\n\t\tthis.parser.setMaterials( this.materialHandler.getMaterials() );\n\n\t\tif ( content instanceof ArrayBuffer || content instanceof Uint8Array ) {\n\n\t\t\tif ( this.parser.logging.enabled ) console.info( 'Parsing arrayBuffer...' );\n\t\t\tthis.parser.execute( content );\n\n\t\t} else if ( typeof ( content ) === 'string' || content instanceof String ) {\n\n\t\t\tif ( this.parser.logging.enabled ) console.info( 'Parsing text...' );\n\t\t\tthis.parser.executeLegacy( content );\n\n\t\t} else {\n\n\t\t\tthis.parser.callbacks.onError( 'Provided content was neither of type String nor Uint8Array! Aborting...' );\n\n\t\t}\n\n\t\tif ( this.parser.logging.enabled ) {\n\n\t\t\tconsole.timeEnd( 'OBJLoader parse: ' + this.modelName );\n\n\t\t}\n\n\t\treturn this.baseObject3d;\n\n\t},\n\n\t_onAssetAvailable: function ( payload ) {\n\n\t\tif ( payload.cmd !== 'assetAvailable' ) return;\n\n\t\tif ( payload.type === 'mesh' ) {\n\n\t\t\tlet meshes = this.meshReceiver.buildMeshes( payload );\n\t\t\tfor ( let mesh of meshes ) {\n\n\t\t\t\tthis.baseObject3d.add( mesh );\n\n\t\t\t}\n\n\t\t} else if ( payload.type === 'material' ) {\n\n\t\t\tthis.materialHandler.addPayloadMaterials( payload );\n\n\t\t}\n\n\t}\n\n} );\n\nexport { OBJLoader2 };\n"],"sourceRoot":""}